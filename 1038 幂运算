/*1038 幂运算
给定两个值x/y，其取值范围均为[1,1000]，将x作为幂运算的底数值，y作为幂运算的指数值，计算 x^y 的结果。
*/

/*IN
有若干组，每组1 行，每行中包含两个数，分别表示x/y的值，中间使用空格分隔。

34 56
102 356
*/

/*OUT
对于输入的每一行，计算一个结果，输出到一行

57918773205287127842044254126179599852840968492056164062843692360166371779746690236416
11525536415592716356648444162121164392687163175948295780407329630004551512959186681381273244602190757058373206291554281875540618042949363675225216676477008497546493670298238521544171633524700764806166227229335118687219889267655183448474160653716777369227626785925762359475294959620339306272244056731636176512806213745898010455096462431289370207384844632477617019982790779702457310729047176281759656263753792457270711025862323789528888545602012704194263073614030101358318488028646734547322466415087427024407008549768556431442559106783257516131690451377322649207503242078203428686238550077244853875462845035889887081653722781635654331259153794693134695552882744378661561578545928174213170104944801295608527030096756736
*/

/*HIT
最大输出数为，1000^1000，即1后面带3000个0。
请注意执行时间及内存限制
*/

#include <iostream>
#include <string.h>
using namespace std;

int sum[3002];
int bit;

void mul(int x)
{
	int carry = 0;
	for (int i = 0; i < bit; i++)
	{
		int tmpMul = sum[i] * x;
		sum[i] = (tmpMul+carry) % 10;
		carry = (tmpMul+carry) / 10;
	}
	while (carry)
	{
		sum[bit] = (carry + sum[bit]) % 10;
		carry = carry / 10;
		bit++;
	}
}

int main()
{
	int x, y;

	while (cin >> x >> y)
	{
		if (x < 1 || x>1000 || y < 1 || y>1000)
		{
			return 0;
		}
		bit = 1;
		memset(sum, 0, sizeof(sum));
		sum[0] = 1;

		for (size_t i = 0; i < y; i++)
		{
			mul(x);
		}
		for (int i = bit - 1; i >= 0; i--)
		{
			cout << sum[i];
		}
		cout << endl;
	}
}
