/*1071 链表反解
已知有链表定义（32位CPU，4字节对齐）：
struct node
{
	struct node* p_next;
	uint32_t     val;
};
现发现由于程序误操作，单向非循环链表形成环形，从而导致遍历时CPU占满重启。我们通过一些手段拿到了重启一瞬间的内存镜像，且定位到了链表首节点的地址ADDR。
请根据内存镜像，解析形成环形链表的异常节点。 设备为小端设备。

附：
正常的单向链表节点顺序为 A -> B -> C -> D。若链表形成 A -> B -> C -> D -> B时，由于D节点错误的再次指向B，导致形成环形链表。因此此处D节点存在异常。
*/

/*IN
测试用例格式如下：
ADDR SIZE
[DUMP]

其中：
ADDR表示链表首节点地址，SIZE为内存镜像大小(单位字节，且必定为16的整数倍)，两者之间用空格分隔
[DUMP]为一段连续内存数据，分为多行，每行表示16字节。行首为当前行的首地址，随后跟随一个“ | ”（注意两侧有空格），之后是十六进制的字节数据dump，每个字节之间空格分割：

00e68138 64
00e68130 | 00 00 00 00 00 00 00 00 40 81 e6 00 01 00 00 00
00e68140 | 48 81 e6 00 02 00 00 00 50 81 e6 00 03 00 00 00
00e68150 | 58 81 e6 00 04 00 00 00 40 81 e6 00 63 00 00 00
00e68160 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

00e68138 64
00e68130 | 00 00 00 00 00 00 00 00 40 81 e6 00 01 00 00 00
00e68140 | 48 81 e6 00 02 00 00 00 50 81 e6 00 03 00 00 00
00e68150 | 58 81 e6 00 04 00 00 00 40 81 e6 00 63 00 00 00
00e68160 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*/

/*OUT
形成环形队列的节点地址。注意长度固定为32位，不足时补0，即e68158 要求输出 00e68158

00e68158
*/
